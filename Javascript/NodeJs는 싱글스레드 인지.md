- 자바스크립트 → 싱글스레디드 랭귀지 : 코드를 한번에 하나밖에 실행하지 못함
- Node JS → 자바스크립트를 브라우저 밖에서도 실행 할 수 있도록 하는 자바스크립트 런타임

- 콜스택과 태스크 큐
    - 자바스크립트 엔진은 요청이 들어올 때마다 요청을 순차적으로 call stack에 담아 하나씩 처리한다. call stack은 하나만 존재하기 때문에 요청도 하나씩만 처리할 수 밖에 없다. task queue는 처리해야 하는 task를 임시로 저장해두는 큐다. call stack이 비워지면 task queue에 있던 task들이 순서대로 call stack에 push된다.

- Node.js는 싱글스레드! 프로세스 내에서 하나의 스레드가 하나의 요청만을 수행함. 한번에 여러 요청을 수행할 수 없음 
  - 하지만 Node.js는 싱글 스레드 논블로킹 모델. 싱글스레드지만 비동기 I/O 작업을 통해 요청들을 서로 블로킹하지 않음. 즉, 동시에 많은 요청들을 비동기로 수행함으로써 싱글 스레드일지라도 논블로킹이 가능.
  - 또한 클러스터링을 통해 프로세스를 포크하여 멀티스레드인것처럼 사용가능
  - 싱글스레드이지만 완전한 싱글 스레드를 기반으로 동작하지는 않음. 일부 작업들은 libuv의 스레드 풀에서 수행되기 때문. libuv 라이브러리가 이벤트기반, 논블로킹 I/O를 구현함
  - 특징 → 이벤트 기반, 논블로킹 I/O 모델
  - Node JS의 특성인 이벤트 기반, 논블로킹 I/O 모델들은 모두 libuv 라이브러리에서 구현됨

- 프로세스: 메모리에 올라와 실행되고 있는 프로그램의 인스턴스. 실행되고 있는 프로그램(독립적인 개체). 운영체제에서 할당하는 작업의 
- 스레드: 프로세스 내에서 할당받은 실행의 단위. 스레드는 프로세스 당 CPU의 코어 개수만큼 생성될 수 있다. 프로세스 내에서 실행되는 흐름의 단위
- 스레드는 프로세스 내의 메모리 공간을 공유하지만, 각각의 프로세스는 별도의 메모리 공간을 갖는다.

정리하자면 Node.js는 우리가 직접 제어할 수 있는 스레드가 단 한 개이기 때문에 싱글 스레드 기반이라고 부른다.
그렇기ㄷ 때문에 효율적으로 클라이언트의 요청을 처리하기 위해서는 이 메인 스레드가 블로킹되거나 멈추지 않게 잘 관리해야 한다.
Node.js는 libuv 라이브러리를 통해 이벤트 기반, 논 블로킹 I/O(외부 API 요청, DB read/write, File I/O)를 만나게 되면, 이벤트 루프가 해당 작업을 백드라운드로 보내게 된다.
그리고 백그라운드에서 OS 커널이 비동기 작업을 지원해주게 되면 커널 단의 함수를 호출한다.
만일 커널이 지원해주지 않을 경우, Node.js를 실행했을 때 생긴 다른 워크 스레드들이 해당 작업을 수행하고 작업이 끝난 뒤 콜백 함수를 다시 이벤트 큐에 등록한다.
그렇다면 마지막으로 이벤트 루프가 이벤트 큐에 등록된 콜백 함수를 메인 스레드로 올리는 역할을 하게 된다.

이렇게 Node.js는 새로운 스레드를 생성하거나 멀티 스레드를 관리하는 데 필요한 작업(lock)을 수행하지 않아도 되기에 다른 언어에 비해 적은 오버헤드를 가지고 있고, 확장성이 크며 개발하기가 쉽다.
다만 블로킹 때문에 CPU 연산을 많이 요구하는 작업에는 적합하지 않다는 단점을 지니고 있다.

- 하나의 스레드로 동작하지만 비동기 작업을 통해 요청들을 서로 블로킹하지 않는다.
- 즉, 동시에 많은 요청들을 비동기로 수행함으로써 싱글스레드일지라도 논블로킹이 가능하도록 구성할 수 있다.

- Node.js는 싱글 스레드 이지만, worker_threads 모듈을 사용하여 여러 작업을 동시에 처리 할 수 있다.
- worker_threads 모듈을 사용하지 않더라도 Node.js 애플리케이션에서 병렬처리가 가능하다
