## GET, POST 방식의 차이점
- GET : 클라이언트는 GET 요청시 URI와 Header 에만 데이터를 담아서 전송할 수 있으므로 데이터 크기가 제한적이며 URI에 포함된 데이터는 사용자에게 그대로 노출된다. GET 요청은 캐싱이 가능하므로 단순 조회이거나 데이터가 사용자에게 노출되어도 상관없다면 적극 활용하는게 좋다.
- POST : 데이터를 URI와 Header 그리고 Body에 담아서 전송할 수 있으므로 GET 방식보다 전송할 수 있는 데이터가 현저히 크다. Body 데이터는 일반 사용자에게 노출되지 않으므로 안정적으로 데이터를 전송할 수 있다.

## TCP 3-way-handshake
Client는 Server에 접속 요청 메세지(SYN)을 전송하고 SYN_SEND 상태가 된다.
Server는 SYN 요청을 받고 Client에 요청을 수락(SYN+ACK)하고 SYN_RECEIVED 상태가 된다.
Client는 Server에게 수락 확인(ACK)를 보내고 Server는 ESTABLISHED 상태가 된다.

### TCP와 UDP의 차이점
TCP : 신뢰성과 순차적인 전달이 필요한 경우 사용한다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.
UDP : 비연결형 프로토콜이며 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. UDP를 사용하는 것에는 DNS가 있다. 사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다.

### HTTP와 HTTPS의 차이점
HTTP의 문제점은 평문 통신이기에 도청이 가능하다는 것, 통신 상대를 확인하지 않기 때문에 위장이 가능하다는 것, 완정성을 증명할 수 없기 때문에 변조가 가능하다는 것이다. TCP/IP 구조의 통신은 패킷을 수집하는 것만으로도 도청할 수 있다. 이를 해결하는 방법으로 통신 자체에 SSL을 적용하거나 콘텐츠 자체를 암호화하고 복호화하는 처리를 진행할 수 있다. 통신 자체에 SSL이 적용된 통신을 HTTPS라 칭한다.

### DNS round robin 방식
DNS를 이용해서 하나의 서비스에 여러 대의 서버를 분산 시키는 방법이다. 동일한 이름으로 여러 레코드를 등록 시키면 질의 할 때마다 다른 결과를 반환하며, 이 동작을 이용함으로써 여러 대의 서버에 처리를 분산 시킬 수 가 있다. 단점은 아래와 같다.

서버의 수 만큼 공인 IP 주소가 필요하다.
DNS 질의 결과 캐싱으로 인해 균등하게 분산되지 않는다.
서버가 다운되어도 확인이 어렵다,

### 트랜잭션
- DB의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.
- 논리적 단위
  - 원자성: 트랜잭션의 연산은 모두 반영/안반영
  - 일관성: 트랜잭션이 성공하면 일관성 있는 DB 상태로 변환한다.
  - 독립성: 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 서로의 연산에 끼어들면 안된다.
  - 영속성: 성공적으로 완료된 결과는 영구적으로 반영
- 트랜잭션 연산 및 상태
- commit - 한 개의 단위가 성공저긍로 끝나고 DB가 다시 일관된 상태에 있을 때 관리자에게 알려주는 연산
- rollback 실패해서 재시작 or 폐기
- 상태
  - 활동: 실행중
  - 실패: 오류가 발생 중단
  - 철회: 비정상적으로 종료되어 Rollback 수행
  - 부분완료: 마지막까지 연산했지만 Commit이 실행되기 직전
  - 완료: 성공 Commit 연산을 실행 후 상태

### 컨테이너
- 소프트웨어를 OS로부터 분리시켜 동작할 때 최소한의 실행환경을 제공하는 것
- 컨테이너 = 패키징

### 프로세스와 스레드의 차이
- 프로세스는 자원을 할당받는 작업의 단위이며, 스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위
